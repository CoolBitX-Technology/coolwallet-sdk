// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

exports.SignMode = {
  "SIGN_MODE_UNSPECIFIED": 0,
  "SIGN_MODE_DIRECT": 1,
  "SIGN_MODE_TEXTUAL": 2,
  "SIGN_MODE_LEGACY_AMINO_JSON": 127
}

var MsgSend = exports.MsgSend = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var MsgDelegate = exports.MsgDelegate = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var MsgUndelegate = exports.MsgUndelegate = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var MsgWithdrawDelegatorReward = exports.MsgWithdrawDelegatorReward = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Fee = exports.Fee = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Coin = exports.Coin = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var TxBody = exports.TxBody = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var PublicKey = exports.PublicKey = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Any = exports.Any = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var AuthInfo = exports.AuthInfo = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var SignerInfo = exports.SignerInfo = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ModeInfo = exports.ModeInfo = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var TxRaw = exports.TxRaw = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineMsgSend()
defineMsgDelegate()
defineMsgUndelegate()
defineMsgWithdrawDelegatorReward()
defineFee()
defineCoin()
defineTxBody()
definePublicKey()
defineAny()
defineAuthInfo()
defineSignerInfo()
defineModeInfo()
defineTxRaw()

function defineMsgSend () {
  MsgSend.encodingLength = encodingLength
  MsgSend.encode = encode
  MsgSend.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.from_address)) throw new Error("from_address is required")
    var len = encodings.string.encodingLength(obj.from_address)
    length += 1 + len
    if (!defined(obj.to_address)) throw new Error("to_address is required")
    var len = encodings.string.encodingLength(obj.to_address)
    length += 1 + len
    if (defined(obj.amount)) {
      for (var i = 0; i < obj.amount.length; i++) {
        if (!defined(obj.amount[i])) continue
        var len = Coin.encodingLength(obj.amount[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.from_address)) throw new Error("from_address is required")
    buf[offset++] = 10
    encodings.string.encode(obj.from_address, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.to_address)) throw new Error("to_address is required")
    buf[offset++] = 18
    encodings.string.encode(obj.to_address, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.amount)) {
      for (var i = 0; i < obj.amount.length; i++) {
        if (!defined(obj.amount[i])) continue
        buf[offset++] = 26
        varint.encode(Coin.encodingLength(obj.amount[i]), buf, offset)
        offset += varint.encode.bytes
        Coin.encode(obj.amount[i], buf, offset)
        offset += Coin.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      from_address: "",
      to_address: "",
      amount: []
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.from_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.to_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.amount.push(Coin.decode(buf, offset, offset + len))
        offset += Coin.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMsgDelegate () {
  MsgDelegate.encodingLength = encodingLength
  MsgDelegate.encode = encode
  MsgDelegate.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.delegator_address)) throw new Error("delegator_address is required")
    var len = encodings.string.encodingLength(obj.delegator_address)
    length += 1 + len
    if (!defined(obj.validator_address)) throw new Error("validator_address is required")
    var len = encodings.string.encodingLength(obj.validator_address)
    length += 1 + len
    if (defined(obj.amount)) {
      var len = Coin.encodingLength(obj.amount)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.delegator_address)) throw new Error("delegator_address is required")
    buf[offset++] = 10
    encodings.string.encode(obj.delegator_address, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.validator_address)) throw new Error("validator_address is required")
    buf[offset++] = 18
    encodings.string.encode(obj.validator_address, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.amount)) {
      buf[offset++] = 26
      varint.encode(Coin.encodingLength(obj.amount), buf, offset)
      offset += varint.encode.bytes
      Coin.encode(obj.amount, buf, offset)
      offset += Coin.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      delegator_address: "",
      validator_address: "",
      amount: null
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.delegator_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.validator_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.amount = Coin.decode(buf, offset, offset + len)
        offset += Coin.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMsgUndelegate () {
  MsgUndelegate.encodingLength = encodingLength
  MsgUndelegate.encode = encode
  MsgUndelegate.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.delegator_address)) throw new Error("delegator_address is required")
    var len = encodings.string.encodingLength(obj.delegator_address)
    length += 1 + len
    if (!defined(obj.validator_address)) throw new Error("validator_address is required")
    var len = encodings.string.encodingLength(obj.validator_address)
    length += 1 + len
    if (defined(obj.amount)) {
      var len = Coin.encodingLength(obj.amount)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.delegator_address)) throw new Error("delegator_address is required")
    buf[offset++] = 10
    encodings.string.encode(obj.delegator_address, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.validator_address)) throw new Error("validator_address is required")
    buf[offset++] = 18
    encodings.string.encode(obj.validator_address, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.amount)) {
      buf[offset++] = 26
      varint.encode(Coin.encodingLength(obj.amount), buf, offset)
      offset += varint.encode.bytes
      Coin.encode(obj.amount, buf, offset)
      offset += Coin.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      delegator_address: "",
      validator_address: "",
      amount: null
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.delegator_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.validator_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.amount = Coin.decode(buf, offset, offset + len)
        offset += Coin.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMsgWithdrawDelegatorReward () {
  MsgWithdrawDelegatorReward.encodingLength = encodingLength
  MsgWithdrawDelegatorReward.encode = encode
  MsgWithdrawDelegatorReward.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.delegator_address)) throw new Error("delegator_address is required")
    var len = encodings.string.encodingLength(obj.delegator_address)
    length += 1 + len
    if (!defined(obj.validator_address)) throw new Error("validator_address is required")
    var len = encodings.string.encodingLength(obj.validator_address)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.delegator_address)) throw new Error("delegator_address is required")
    buf[offset++] = 10
    encodings.string.encode(obj.delegator_address, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.validator_address)) throw new Error("validator_address is required")
    buf[offset++] = 18
    encodings.string.encode(obj.validator_address, buf, offset)
    offset += encodings.string.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      delegator_address: "",
      validator_address: ""
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.delegator_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.validator_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineFee () {
  Fee.encodingLength = encodingLength
  Fee.encode = encode
  Fee.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.amount)) {
      for (var i = 0; i < obj.amount.length; i++) {
        if (!defined(obj.amount[i])) continue
        var len = Coin.encodingLength(obj.amount[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.gas_limit)) {
      var len = encodings.varint.encodingLength(obj.gas_limit)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.amount)) {
      for (var i = 0; i < obj.amount.length; i++) {
        if (!defined(obj.amount[i])) continue
        buf[offset++] = 10
        varint.encode(Coin.encodingLength(obj.amount[i]), buf, offset)
        offset += varint.encode.bytes
        Coin.encode(obj.amount[i], buf, offset)
        offset += Coin.encode.bytes
      }
    }
    if (defined(obj.gas_limit)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.gas_limit, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      amount: [],
      gas_limit: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.amount.push(Coin.decode(buf, offset, offset + len))
        offset += Coin.decode.bytes
        break
        case 2:
        obj.gas_limit = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineCoin () {
  Coin.encodingLength = encodingLength
  Coin.encode = encode
  Coin.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.denom)) {
      var len = encodings.string.encodingLength(obj.denom)
      length += 1 + len
    }
    if (defined(obj.amount)) {
      var len = encodings.string.encodingLength(obj.amount)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.denom)) {
      buf[offset++] = 10
      encodings.string.encode(obj.denom, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.amount)) {
      buf[offset++] = 18
      encodings.string.encode(obj.amount, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      denom: "",
      amount: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.denom = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        obj.amount = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineTxBody () {
  TxBody.encodingLength = encodingLength
  TxBody.encode = encode
  TxBody.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.messages)) {
      for (var i = 0; i < obj.messages.length; i++) {
        if (!defined(obj.messages[i])) continue
        var len = Any.encodingLength(obj.messages[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.memo)) {
      var len = encodings.string.encodingLength(obj.memo)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.messages)) {
      for (var i = 0; i < obj.messages.length; i++) {
        if (!defined(obj.messages[i])) continue
        buf[offset++] = 10
        varint.encode(Any.encodingLength(obj.messages[i]), buf, offset)
        offset += varint.encode.bytes
        Any.encode(obj.messages[i], buf, offset)
        offset += Any.encode.bytes
      }
    }
    if (defined(obj.memo)) {
      buf[offset++] = 18
      encodings.string.encode(obj.memo, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      messages: [],
      memo: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.messages.push(Any.decode(buf, offset, offset + len))
        offset += Any.decode.bytes
        break
        case 2:
        obj.memo = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePublicKey () {
  PublicKey.encodingLength = encodingLength
  PublicKey.encode = encode
  PublicKey.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.value)) {
      var len = encodings.bytes.encodingLength(obj.value)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.value)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.value, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      value: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.value = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineAny () {
  Any.encodingLength = encodingLength
  Any.encode = encode
  Any.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.type_url)) {
      var len = encodings.string.encodingLength(obj.type_url)
      length += 1 + len
    }
    if (defined(obj.value)) {
      var len = encodings.bytes.encodingLength(obj.value)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.type_url)) {
      buf[offset++] = 10
      encodings.string.encode(obj.type_url, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.value)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.value, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      type_url: "",
      value: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.type_url = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        obj.value = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineAuthInfo () {
  AuthInfo.encodingLength = encodingLength
  AuthInfo.encode = encode
  AuthInfo.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.signer_infos)) {
      for (var i = 0; i < obj.signer_infos.length; i++) {
        if (!defined(obj.signer_infos[i])) continue
        var len = encodings.bytes.encodingLength(obj.signer_infos[i])
        length += 1 + len
      }
    }
    if (defined(obj.fee)) {
      var len = encodings.bytes.encodingLength(obj.fee)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.signer_infos)) {
      for (var i = 0; i < obj.signer_infos.length; i++) {
        if (!defined(obj.signer_infos[i])) continue
        buf[offset++] = 10
        encodings.bytes.encode(obj.signer_infos[i], buf, offset)
        offset += encodings.bytes.encode.bytes
      }
    }
    if (defined(obj.fee)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.fee, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      signer_infos: [],
      fee: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.signer_infos.push(encodings.bytes.decode(buf, offset))
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.fee = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSignerInfo () {
  SignerInfo.encodingLength = encodingLength
  SignerInfo.encode = encode
  SignerInfo.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.public_key)) {
      var len = encodings.bytes.encodingLength(obj.public_key)
      length += 1 + len
    }
    if (defined(obj.mode_info)) {
      var len = ModeInfo.encodingLength(obj.mode_info)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.sequence)) {
      var len = encodings.varint.encodingLength(obj.sequence)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.public_key)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.public_key, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.mode_info)) {
      buf[offset++] = 18
      varint.encode(ModeInfo.encodingLength(obj.mode_info), buf, offset)
      offset += varint.encode.bytes
      ModeInfo.encode(obj.mode_info, buf, offset)
      offset += ModeInfo.encode.bytes
    }
    if (defined(obj.sequence)) {
      buf[offset++] = 24
      encodings.varint.encode(obj.sequence, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      public_key: null,
      mode_info: null,
      sequence: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.public_key = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.mode_info = ModeInfo.decode(buf, offset, offset + len)
        offset += ModeInfo.decode.bytes
        break
        case 3:
        obj.sequence = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineModeInfo () {
  var Single = ModeInfo.Single = {
    buffer: true,
    encodingLength: null,
    encode: null,
    decode: null
  }

  defineSingle()

  function defineSingle () {
    Single.encodingLength = encodingLength
    Single.encode = encode
    Single.decode = decode

    function encodingLength (obj) {
      var length = 0
      if (defined(obj.mode)) {
        var len = encodings.enum.encodingLength(obj.mode)
        length += 1 + len
      }
      return length
    }

    function encode (obj, buf, offset) {
      if (!offset) offset = 0
      if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
      var oldOffset = offset
      if (defined(obj.mode)) {
        buf[offset++] = 8
        encodings.enum.encode(obj.mode, buf, offset)
        offset += encodings.enum.encode.bytes
      }
      encode.bytes = offset - oldOffset
      return buf
    }

    function decode (buf, offset, end) {
      if (!offset) offset = 0
      if (!end) end = buf.length
      if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
      var oldOffset = offset
      var obj = {
        mode: 0
      }
      while (true) {
        if (end <= offset) {
          decode.bytes = offset - oldOffset
          return obj
        }
        var prefix = varint.decode(buf, offset)
        offset += varint.decode.bytes
        var tag = prefix >> 3
        switch (tag) {
          case 1:
          obj.mode = encodings.enum.decode(buf, offset)
          offset += encodings.enum.decode.bytes
          break
          default:
          offset = skip(prefix & 7, buf, offset)
        }
      }
    }
  }

  ModeInfo.encodingLength = encodingLength
  ModeInfo.encode = encode
  ModeInfo.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.single)) > 1) throw new Error("only one of the properties defined in oneof sum can be set")
    if (defined(obj.single)) {
      var len = Single.encodingLength(obj.single)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.single)) > 1) throw new Error("only one of the properties defined in oneof sum can be set")
    if (defined(obj.single)) {
      buf[offset++] = 10
      varint.encode(Single.encodingLength(obj.single), buf, offset)
      offset += varint.encode.bytes
      Single.encode(obj.single, buf, offset)
      offset += Single.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      single: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.single = Single.decode(buf, offset, offset + len)
        offset += Single.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineTxRaw () {
  TxRaw.encodingLength = encodingLength
  TxRaw.encode = encode
  TxRaw.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.body_bytes)) {
      var len = encodings.bytes.encodingLength(obj.body_bytes)
      length += 1 + len
    }
    if (defined(obj.auth_info_bytes)) {
      var len = encodings.bytes.encodingLength(obj.auth_info_bytes)
      length += 1 + len
    }
    if (defined(obj.signatures)) {
      for (var i = 0; i < obj.signatures.length; i++) {
        if (!defined(obj.signatures[i])) continue
        var len = encodings.bytes.encodingLength(obj.signatures[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.body_bytes)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.body_bytes, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.auth_info_bytes)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.auth_info_bytes, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signatures)) {
      for (var i = 0; i < obj.signatures.length; i++) {
        if (!defined(obj.signatures[i])) continue
        buf[offset++] = 26
        encodings.bytes.encode(obj.signatures[i], buf, offset)
        offset += encodings.bytes.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      body_bytes: null,
      auth_info_bytes: null,
      signatures: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.body_bytes = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.auth_info_bytes = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.signatures.push(encodings.bytes.decode(buf, offset))
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
