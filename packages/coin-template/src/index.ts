import crypto from 'crypto';
import { coin as COIN, Transport, utils, config, apdu, tx } from '@coolwallet/core';

const bip32 = require('bip32');
const elliptic = require('elliptic');
const ec = new elliptic.ec('secp256k1');
const createKeccakHash = require('keccak')
const rlp = require('rlp');

import { Transaction, handleHex, getRawTx } from './utils';

export default class Template implements COIN.Coin {
  getPublicKey = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number
  ): Promise<string> => {
    const { accPublicKey, accChainCode } = await this.getAccountPubKeyAndChainCode(transport, appId, appPrivateKey);
    return this.getPublicKeyByAccountKey(accPublicKey, accChainCode, addressIndex);
  };

  getAccountPubKeyAndChainCode = async (
    transport: Transport,
    appId: string,
    appPrivateKey: string
  ): Promise<{accPublicKey:string, accChainCode:string}> => {


    // *** 1. Full Path ***

    // The fullPath follows BIP-32 and BIP-44 rules with a pathType prefix.
    // The fullPath is applied to indicate the derived key for either generating
    // public keys or signing transaction.

    // Format : [pathType (1B)] [index (4B)] [index (4B)] ...
    // pathType : BIP32='32', SLIP0010='10',BIP32EDDSA='42', BIP32ED25519='17'

    // path output : 328000002c8000003c80000000

    const path = utils.getFullPath({
      pathType: config.PathType.BIP32,
      pathString: "44'/60'/0'",
    });


    // *** 2. Get Public Key by Full Path ***

    // One of the benefits to conform BIP-32 is able to derive non-hardened child
    // public keys with a parent public key. It is recommended to store the parent
    // key then uses it to generate the child public key efficiently by avoiding
    // connecting to the card.

    const accExtKey = await COIN.getPublicKeyByPath(transport, appId, appPrivateKey, path);
    const accExtKeyBuf = Buffer.from(accExtKey, 'hex');
    const accPublicKey = accExtKeyBuf.slice(0, 33).toString('hex');
    const accChainCode = accExtKeyBuf.slice(33).toString('hex');
    return { accPublicKey, accChainCode };
  };

  getPublicKeyByAccountKey = (
    accPublicKey: string,
    accChainCode: string,
    addressIndex: number
  ): string => {
    const accNode = bip32.fromPublicKey(
      Buffer.from(accPublicKey, 'hex'),
      Buffer.from(accChainCode, 'hex'));
    const changeNode = accNode.derive(0);
    const addressNode = changeNode.derive(addressIndex);
    const publicKey = addressNode.publicKey.toString('hex');
    return publicKey;
  };

  publicKeyToAddress = (publicKey: string) => {
    const uncompressedKey = ec.keyFromPublic(publicKey, 'hex').getPublic(false, 'hex');
    const keyBuffer = Buffer.from(uncompressedKey.substr(2), 'hex');
    const keyHash = createKeccakHash('keccak256').update(keyBuffer).digest('hex');
    const address = '0x'.concat(keyHash.substr(-40));
    return address;
  };

  getAddress = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number
  ): Promise<string> => {
    const publicKey = await this.getPublicKey(transport, appPrivateKey, appId, addressIndex);
    return this.publicKeyToAddress(publicKey);
  };

  getAddressByAccountKey = async (
    accPublicKey: string,
    accChainCode: string,
    addressIndex: number
  ): Promise<string> => {
    const publicKey = await this.getPublicKeyByAccountKey(accPublicKey, accChainCode, addressIndex);
    return this.publicKeyToAddress(publicKey);
  };

  signTransaction = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number,
    transaction: Transaction
  ): Promise<string> => {


    // *** 3. Scriptable Signing ***

    // Scriptable Signing is a process to generate a signature by setting a script
    // and arguments consecutively.

    // 3-1. Script

    // The script aims to describe how a signed data composed from arguments
    // and what to display on the screen for validation.
    // (eg. amount, to-address)

    const script = '03000601C707000000003CCC07C002F800C2ACD70032FFF8C2ACD7001EFFF6C2ACD70028FFF6CC071094CAA02700C2A2D700FFF6C2AC97003CCC0E1001C2E09700CC07C0028080C37097C002DC07C003455448D207C005534d415254D207CC05065052455353425554546f4e';

    // The script signature is generated by the coolwallet team. It secures the
    // transaction against abused formats.

    const scriptSig = '3046022100EC9BC856CEC733451CF4063C60DE27F9E920F7423122CCA19DC47B82E694799C0221008F754911B9C966EF430ED8919A58333D9800E8EBF4FB98B06C797E991DA03697';

    await apdu.tx.sendScript(transport, script + scriptSig);

    // 3-2. Arguments

    // The arguments are concatenated with custom length and prefixed with
    // a full path. The order of arguments depends on the script. Commands in
    // a script should bring the offset and the length to fetch argument.
    //
    // Format : [fullPath length (1B)] [fullPath (~)] [arguments (~)]

    const path = await utils.getFullPath({
      pathType: config.PathType.BIP32,
      pathString: "44'/60'/0'/0/0",
    });
    console.log('path :', path);

    const argument = '15' + path +
      handleHex(transaction.to) +
      handleHex(transaction.value).padStart(20, "0") +
      handleHex(transaction.gasPrice).padStart(20, "0") +
      handleHex(transaction.gasLimit).padStart(20, "0") +
      handleHex(transaction.nonce).padStart(16, "0") +
      handleHex(transaction.chainId.toString(16)).padStart(4, "0") +
      handleHex(transaction.data);


    // *** 4. Validation and The Encrypted Signature ***

    // The executeScript sends arguments and returns a encrypted signature. 
    // A decripting key would be received after transaction validation.

    const encryptedSig = await apdu.tx.executeScript(
      transport,
      appId,
      appPrivateKey,
      argument
    );

    // 4-1. The finishPrepare should always be called to end the signing session.

    await apdu.tx.finishPrepare(transport);

    // 4-2. The getTxDetail starts the validation session and displays the transaction
    // information on the screen.

    await apdu.tx.getTxDetail(transport);

    // 4-3. After pressing the button for validating transaction information,
    // the getSignatureKey is allowed to be called to return the decrypting key.

    const decryptingKey = await apdu.tx.getSignatureKey(transport);

    // 4-4. Close the validation session.

    await apdu.tx.clearTransaction(transport);

    // 4-5. Call powerOff to reset the screen display.

    await apdu.mcu.control.powerOff(transport);


    // *** 5. Decrypting Signature and Constructing The Signed Transaction ***

    // 5-1. Get the real signature for the transaction

    const sig = tx.util.decryptSignatureFromSE(encryptedSig!, decryptingKey);

    // 5-2. (Optional) The getSignedHex is available to check the raw transaction
    // generated by the scriptable signing.

    const { signedTx } = await apdu.tx.getSignedHex(transport);
    const rawTx = getRawTx(transaction);
    const rawData = rlp.encode(rawTx);
    if (rawData.toString('hex') !== signedTx) {
      throw new Error('unexpected transaction format!');
    }

    // 5-3. As a result, a signed transaction should be constructed and return to
    // the client who uses this coin sdk. The signed transactions vary from each
    // other. Please refer to the coin specification which you are integrating.
    // Below sample code is from ETH.

    const hash = createKeccakHash('keccak256').update(rawData).digest('hex');
    const data = Buffer.from(handleHex(hash), 'hex');

    const publicKey = await this.getPublicKey(
      transport, appPrivateKey, appId, addressIndex
    );

    const keyPair = ec.keyFromPublic(publicKey, 'hex');

    const recoveryParam = ec.getKeyRecoveryParam(data, sig, keyPair.pub);
    const v = recoveryParam + 27;
    const { r, s } = sig as { r: string; s: string; };

    const vValue = v + transaction.chainId * 2 + 8;
    const signedTransaction = rawTx.slice(0, 6);
    signedTransaction.push(
      Buffer.from([vValue]),
      Buffer.from(r, 'hex'),
      Buffer.from(s, 'hex')
    );
    const serializedTx = rlp.encode(signedTransaction);
    return `0x${serializedTx.toString('hex')}`;
  };
}
