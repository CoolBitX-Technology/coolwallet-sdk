import crypto from 'crypto';
import { coin as COIN, Transport, utils, config, apdu, tx } from '@coolwallet/core';
import crc from 'crc';
import base58 from 'bs58';
// const crc = require('crc')
// const base58 = require('bs58')

const bip32 = require('bip32');
const elliptic = require('elliptic');
const ec = new elliptic.ec('secp256k1');
const createKeccakHash = require('keccak');
const rlp = require('rlp');

import { Transaction, handleHex, getRawTx } from './utils';

type versionByteNames = 'ed25519PublicKey' | 'ed25519SecretSeed' | 'preAuthTx' | 'sha256Hash';

const params = {
  VERSION_BYTES: {
    ed25519PublicKey: 6 << 3, // G
    ed25519SecretSeed: 18 << 3, // S
    preAuthTx: 19 << 3, // T
    sha256Hash: 23 << 3, // X
  },
};

function calculateChecksum(payload: Buffer) {
  // This code calculates CRC16-XModem checksum of payload
  // and returns it as Buffer in little-endian order.
  const checksum = Buffer.allocUnsafe(2);
  checksum.writeUInt16LE(crc.crc16xmodem(payload), 0);
  return checksum;
}

export function encodeCheck(versionByteName: versionByteNames, data: Buffer) {
  const versionByte = params.VERSION_BYTES[versionByteName];

  const versionBuffer = Buffer.from([versionByte]);
  const payload = Buffer.concat([versionBuffer, data]);
  const checksum = calculateChecksum(payload);
  const unencoded = Buffer.concat([payload, checksum]);

  return base58.encode(unencoded);
}

export function encodeEd25519PublicKey(data: Buffer) {
  return encodeCheck('ed25519PublicKey', data);
}

export function pubKeyToAddress(publicKey: string): string {
  const pubKey = publicKey.length === 66 ? publicKey.slice(2) : publicKey;

  const pubKeyBuf = Buffer.from(pubKey, 'hex');
  return encodeEd25519PublicKey(pubKeyBuf);
}

export default class Template implements COIN.Coin {
  getPublicKey = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number
  ): Promise<string> => {
    // *** 1. Full Path ***

    // The fullPath follows BIP-32 and BIP-44 rules with a pathType prefix.
    // The fullPath is applied to indicate the derived key for either generating
    // public keys or signing transaction.

    // Format : [pathType (1B)] [index (4B)] [index (4B)] ...
    // pathType : BIP32='32', SLIP0010='10',BIP32EDDSA='42', BIP32ED25519='17'

    // path output : 328000002c8000003c80000000

    const path = utils.getFullPath({
      pathType: config.PathType.BIP32,
      pathString: "44'/2017'/0'/1'",
    });

    // *** 2. Get Public Key by Full Path ***

    // One of the benefits to conform BIP-32 is able to derive non-hardened child
    // public keys with a parent public key. It is recommended to store the parent
    // key then uses it to generate the child public key efficiently by avoiding
    // connecting to the card.

    const accExtKey = await COIN.getPublicKeyByPath(transport, appId, appPrivateKey, path);
    const accExtKeyBuf = Buffer.from(accExtKey, 'hex');
    const accPublicKey = accExtKeyBuf.slice(0, 33);
    const accChainCode = accExtKeyBuf.slice(33);

    const accNode = bip32.fromPublicKey(accPublicKey, accChainCode);
    const changeNode = accNode.derive(0);
    const addressNode = changeNode.derive(addressIndex);
    const publicKey = addressNode.publicKey.toString('hex');
    return publicKey;
  };

  getAddress = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number
  ): Promise<string> => {
    const publicKey = await this.getPublicKey(transport, appPrivateKey, appId, addressIndex);
    // const address = pubKeyToAddress(publicKey)
    // const uncompressedKey = ec.keyFromPublic(publicKey, "hex").getPublic(false, 'hex');
    // const keyBuffer = Buffer.from(uncompressedKey.substr(2), 'hex');
    // const keyHash = createKeccakHash('keccak256').update(keyBuffer).digest('hex');
    // const address = "0x".concat(keyHash.substr(-40));
    return publicKey;
  };

  signTransaction = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number,
    transaction: Transaction,
    script: string,
    argument: string
  ): Promise<any> => {
    try {
      // *** 3. Scriptable Signing ***

      // Scriptable Signing is a process to generate a signature by setting a script
      // and arguments consecutively.

      // 3-1. Script

      // The script aims to describe how a signed data composed from arguments
      // and what to display on the screen for validation.
      // (eg. amount, to-address)

      // const script = '03000202C7070000000091CC07C0022001CAAC570022CC07C0023333CAA0C70016C2ACC700160CCC071099CC07C0028080C3709710DC07C003534F4CBAA0CF6C160E04DDF09700DAACC7C0160C0AD207CC05065052455353425554544F4E';

      // The script signature is generated by the coolwallet team. It secures the
      // transaction against abused formats.

      const scriptSig =
        'FA0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';

      await apdu.tx.sendScript(transport, script + scriptSig);

      // 3-2. Arguments

      // The arguments are concatenated with custom length and prefixed with
      // a full path. The order of arguments depends on the script. Commands in
      // a script should bring the offset and the length to fetch argument.
      //
      // Format : [fullPath length (1B)] [fullPath (~)] [arguments (~)]

      const path = await utils.getFullPath({
        pathType: config.PathType.BIP32,
        // pathString: "44'/60'/0'/0/0",
        pathString: "44'/501'/0'",
      });
      console.log('path :', path);

      const newTx = transaction as any;

      // const argument = '15' + path +
      //   handleHex(Buffer.from(transaction.to).toString('hex')) +
      //   handleHex(newTx.fee).padStart(20, "0") +
      //   handleHex(newTx.amount).padStart(20, "0") +
      //   handleHex(transaction.data);
      const extendArgument = '15' + path + argument;

      console.log('ðŸš€ ~ file: index.ts ~ line 119 ~ Template ~ argument', extendArgument);

      // *** 4. Validation and The Encrypted Signature ***

      // The executeScript sends arguments and returns a encrypted signature.
      // A decripting key would be received after transaction validation.

      const encryptedSig = await apdu.tx.executeScript(transport, appId, appPrivateKey, extendArgument);

      console.log('encryptedSig', encryptedSig);

      // 4-1. The finishPrepare should always be called to end the signing session.

      await apdu.tx.finishPrepare(transport);

      // 4-2. The getTxDetail starts the validation session and displays the transaction
      // information on the screen.

      await apdu.tx.getTxDetail(transport);

      // 4-3. After pressing the button for validating transaction information,
      // the getSignatureKey is allowed to be called to return the decrypting key.

      const decryptingKey = await apdu.tx.getSignatureKey(transport);
      console.log('decryptingKey', decryptingKey);
      // 4-4. Close the validation session.

      await apdu.tx.clearTransaction(transport);

      // 4-5. Call powerOff to reset the screen display.

      await apdu.mcu.control.powerOff(transport);

      // *** 5. Decrypting Signature and Constructing The Signed Transaction ***

      // 5-1. Get the real signature for the transaction

      const sig = tx.util.decryptSignatureFromSE(encryptedSig!, decryptingKey);
      console.log('sig', sig);
      // 5-2. (Optional) The getSignedHex is available to check the raw transaction
      // generated by the scriptable signing.

      const { signedTx } = await apdu.tx.getSignedHex(transport);
      console.log('signedTx', signedTx);
      const rawTx = getRawTx(transaction);
      // const rawData = rlp.encode(rawTx);
      // if (rawData.toString('hex') !== signedTx) {
      //   throw new Error('unexpected transaction format!');
      // }

      // 5-3. As a result, a signed transaction should be constructed and return to
      // the client who uses this coin sdk. The signed transactions vary from each
      // other. Please refer to the coin specification which you are integrating.
      // Below sample code is from ETH.

      // const hash = createKeccakHash('keccak256').update(rawData).digest('hex');
      // const data = Buffer.from(handleHex(hash), 'hex');

      // const publicKey = await this.getPublicKey(
      //   transport, appPrivateKey, appId, addressIndex
      // );

      // const keyPair = ec.keyFromPublic(publicKey, 'hex');

      // const recoveryParam = ec.getKeyRecoveryParam(data, sig, keyPair.pub);
      // const v = recoveryParam + 27;
      // const { r, s } = sig as { r: string; s: string; };

      // const vValue = v + transaction.chainId * 2 + 8;
      // const signedTransaction = rawTx.slice(0, 6);
      // signedTransaction.push(
      //   Buffer.from([vValue]),
      //   Buffer.from(r, 'hex'),
      //   Buffer.from(s, 'hex')
      // );
      // const serializedTx = rlp.encode(signedTransaction);
      return 'success';
    } catch (error) {
      console.log('errrrrrrrrrrr: ', error);
    }
  };
}
