import crypto from 'crypto';
import { coin as COIN, Transport, utils, config, apdu, tx } from '@coolwallet/core';

const bip32 = require('bip32');
const elliptic = require('elliptic');
const ec = new elliptic.ec('secp256k1');
const createKeccakHash = require('keccak');
const rlp = require('rlp');

import { Transaction, handleHex, getRawTx } from './utils';

export default class Template implements COIN.Coin {
  getPublicKey = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number
  ): Promise<string> => {
    // *** 1. Full Path ***

    // The fullPath follows BIP-32 and BIP-44 rules with a pathType prefix.
    // The fullPath is applied to indicate the derived key for either generating
    // public keys or signing transaction.

    // Format : [pathType (1B)] [index (4B)] [index (4B)] ...
    // pathType : BIP32='32', SLIP0010='10',BIP32EDDSA='42', BIP32ED25519='17'

    // path output : 328000002c8000003c80000000

    const path = utils.getFullPath({
      pathType: config.PathType.BIP32,
      pathString: "44'/60'/0'",
    });

    // *** 2. Get Public Key by Full Path ***

    // One of the benefits to conform BIP-32 is able to derive non-hardened child
    // public keys with a parent public key. It is recommended to store the parent
    // key then uses it to generate the child public key efficiently by avoiding
    // connecting to the card.

    const accExtKey = await COIN.getPublicKeyByPath(transport, appId, appPrivateKey, path);
    const accExtKeyBuf = Buffer.from(accExtKey, 'hex');
    const accPublicKey = accExtKeyBuf.slice(0, 33);
    const accChainCode = accExtKeyBuf.slice(33);

    const accNode = bip32.fromPublicKey(accPublicKey, accChainCode);
    const changeNode = accNode.derive(0);
    const addressNode = changeNode.derive(addressIndex);
    const publicKey = addressNode.publicKey.toString('hex');
    return publicKey;
  };

  getAddress = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number
  ): Promise<string> => {
    const publicKey = await this.getPublicKey(transport, appPrivateKey, appId, addressIndex);
    const uncompressedKey = ec.keyFromPublic(publicKey, 'hex').getPublic(false, 'hex');
    const keyBuffer = Buffer.from(uncompressedKey.substr(2), 'hex');
    const keyHash = createKeccakHash('keccak256').update(keyBuffer).digest('hex');
    const address = '0x'.concat(keyHash.substr(-40));
    return address;
  };

  signTransaction = async (
    transport: Transport,
    appPrivateKey: string,
    appId: string,
    addressIndex: number,
    transaction: Transaction
  ): Promise<string> => {
    // *** 3. Scriptable Signing ***

    // Scriptable Signing is a process to generate a signature by setting a script
    // and arguments consecutively.

    // 3-1. Script

    // The script aims to describe how a signed data composed from arguments
    // and what to display on the screen for validation.
    // (eg. amount, to-address)

    const script =
      '03000601C707000000003CCC07C002F800C2ACD70032FFF8C2ACD7001EFFF6C2ACD70028FFF6CC071094CAA02700C2A2D700FFF6C2AC97003CCC0E1001C2E09700CC07C0028080C37097C002DC07C003455448D207C005534d415254D207CC05065052455353425554546f4e';

    // The script signature is generated by the coolwallet team. It secures the
    // transaction against abused formats.

    const scriptSig =
      '3046022100EC9BC856CEC733451CF4063C60DE27F9E920F7423122CCA19DC47B82E694799C0221008F754911B9C966EF430ED8919A58333D9800E8EBF4FB98B06C797E991DA03697';

    await apdu.tx.sendScript(transport, script + scriptSig);

    // 3-2. Arguments

    // The arguments are concatenated with custom length and prefixed with
    // a full path. The order of arguments depends on the script. Commands in
    // a script should bring the offset and the length to fetch argument.
    //
    // Format : [fullPath length (1B)] [fullPath (~)] [arguments (~)]

    const path = await utils.getFullPath({
      pathType: config.PathType.BIP32,
      pathString: "44'/60'/0'/0/0",
    });
    console.log('path :', path);

    const argument =
      '15' +
      path +
      handleHex(transaction.to) +
      handleHex(transaction.value).padStart(20, '0') +
      handleHex(transaction.gasPrice).padStart(20, '0') +
      handleHex(transaction.gasLimit).padStart(20, '0') +
      handleHex(transaction.nonce).padStart(16, '0') +
      handleHex(transaction.chainId.toString(16)).padStart(4, '0') +
      handleHex(transaction.data);

    // *** 4. Validation and The Encrypted Signature ***

    // The executeScript sends arguments and returns a encrypted signature.
    // A decripting key would be received after transaction validation.

    const encryptedSig = await apdu.tx.executeScript(transport, appId, appPrivateKey, argument);

    // 4-1. The finishPrepare should always be called to end the signing session.

    await apdu.tx.finishPrepare(transport);

    // 4-2. The getTxDetail starts the validation session and displays the transaction
    // information on the screen.

    await apdu.tx.getTxDetail(transport);

    // 4-3. After pressing the button for validating transaction information,
    // the getSignatureKey is allowed to be called to return the decrypting key.

    const decryptingKey = await apdu.tx.getSignatureKey(transport);

    // 4-4. Close the validation session.

    await apdu.tx.clearTransaction(transport);

    // 4-5. Call powerOff to reset the screen display.

    await apdu.mcu.control.powerOff(transport);

    // *** 5. Decrypting Signature and Constructing The Signed Transaction ***

    // 5-1. Get the real signature for the transaction

    const sig = tx.util.decryptSignatureFromSE(encryptedSig!, decryptingKey);

    // 5-2. (Optional) The getSignedHex is available to check the raw transaction
    // generated by the scriptable signing.

    const { signedTx } = await apdu.tx.getSignedHex(transport);
    const rawTx = getRawTx(transaction);
    const rawData = rlp.encode(rawTx);
    if (rawData.toString('hex') !== signedTx) {
      throw new Error('unexpected transaction format!');
    }

    // 5-3. As a result, a signed transaction should be constructed and return to
    // the client who uses this coin sdk. The signed transactions vary from each
    // other. Please refer to the coin specification which you are integrating.
    // Below sample code is from ETH.

    const hash = createKeccakHash('keccak256').update(rawData).digest('hex');
    const data = Buffer.from(handleHex(hash), 'hex');

    const publicKey = await this.getPublicKey(transport, appPrivateKey, appId, addressIndex);

    const keyPair = ec.keyFromPublic(publicKey, 'hex');

    const recoveryParam = ec.getKeyRecoveryParam(data, sig, keyPair.pub);
    const v = recoveryParam + 27;
    const { r, s } = sig as { r: string; s: string };

    const vValue = v + transaction.chainId * 2 + 8;
    const signedTransaction = rawTx.slice(0, 6);
    signedTransaction.push(Buffer.from([vValue]), Buffer.from(r, 'hex'), Buffer.from(s, 'hex'));
    const serializedTx = rlp.encode(signedTransaction);
    return `0x${serializedTx.toString('hex')}`;
  };
}
